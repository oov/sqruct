package gen

const createTableTemplate = `CREATE TABLE {{.SQLName}}(
	{{range $k, $v := .Column}}{{if $k}},
	{{end}}{{$v.SQLName}} {{$v.SQLColumn}}{{end}}{{range $k, $v := .ColumnAfter}},
	{{$v}}{{end}}
);`

const dropTableTemplate = `DROP TABLE {{.SQLName}};`

const sourceTemplate = `

// DO NOT EDIT. This file was auto-generated by Sqruct.

package {{.PackageName}}

// {{.GoName}} represents the following table.
{{.MustCreateTableSQL.AddPrefix "// \t"}}
type {{.GoName}} struct {
	schema zz{{.GoName}}
{{range $k, $v := .Column}}  {{$v.GoName}} {{$v.GoStructFieldWithTag}}
{{end}}}

{{$method := print "Get" .GoName}}
{{if .OmitMethod $method}}/*{{end}}
func {{$method}}(db sqruct.DB{{range $k, $v := .PrimaryKey.Column}}, {{$v.SQLName}} {{$v.GoStructFieldType}}{{end}}) (*{{.GoName}}, error) {
	{{$ph := .Mode.Placeholder}}
	var t {{.GoName}}
  err := db.QueryRow(
		"SELECT {{range $k, $v := .Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}} FROM {{.SQLName}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}},
	).Scan({{range $k, $v := .Column}}{{if $k}}, {{end}}&t.{{$v.GoName}}{{end}})
	if err != nil {
  	return nil, err
  }
  return &t, nil

}
{{if .OmitMethod $method}}*/{{end}}

{{$t := .}}
{{range $_, $fk := .ForeignKey}}
{{if and (eq (len $fk.Column) 1) (index $fk.Column 0).Other.PrimaryKey}}
{{$method := print "Get" $fk.Table.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(db sqruct.DB) (*{{$fk.Table.GoName}}, error) {
	{{$ph := $t.Mode.Placeholder}}
	var ot {{$fk.Table.GoName}}
  err := db.QueryRow(
		"SELECT {{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}} FROM {{$fk.Table.SQLName}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.SQLName}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := $fk.Column}}{{if $k}}, {{end}}t.{{$v.Self.GoName}}{{end}},
	).Scan({{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}&ot.{{$v.GoName}}{{end}})
	if err != nil {
  	return nil, err
  }
  return &ot, nil

}
{{if $t.OmitMethod $method}}*/{{end}}
{{else}}
{{$method := print "Select" $fk.Table.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(db sqruct.DB) ([]{{$fk.Table.GoName}}, error) {
	{{$ph := $t.Mode.Placeholder}}
	r, err := db.Query(
		"SELECT {{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}} FROM {{$fk.Table.SQLName}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.SQLName}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := $fk.Column}}{{if $k}}, {{end}}t.{{$v.Self.GoName}}{{end}},
	)
  if err != nil {
  	return nil, err
  }
	defer r.Close()

	ot := []{{$fk.Table.GoName}}{}
	for r.Next() {
		var e {{$fk.Table.GoName}}
		if err = r.Scan({{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}&e.{{$v.GoName}}{{end}}); err != nil {
  		return nil, err
  	}
		ot = append(ot, e)
	}
	if err = r.Err(); err != nil {
		return nil, err
	}
	return ot, nil

}
{{if $t.OmitMethod $method}}*/{{end}}
{{end}}
{{end}}

{{$t := .}}
{{range $_, $m2m := .ManyToMany}}
{{$relTable := $m2m.RelTable}}
{{$oTable := $m2m.OtherFK.Table}}
{{$method := print "Select" $oTable.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(db sqruct.DB) ([]{{$oTable.GoName}}, []{{$relTable.GoName}}, error) {
	{{$ph := $t.Mode.Placeholder}}
	r, err := db.Query(
		"SELECT {{range $k, $v := $oTable.Column}}{{if $k}}, {{end}}{{$oTable.SQLName}}.{{$v.SQLName}}{{end}}{{range $k, $v := $relTable.Column}}, {{$relTable.SQLName}}.{{$v.SQLName}}{{end}} FROM {{$relTable.SQLName}}, {{$oTable.SQLName}} WHERE {{range $k, $v := $m2m.MyFK.Column}}{{if $k}}AND{{end}}({{$relTable.SQLName}}.{{$v.Self.SQLName}} = {{$ph.Next}}){{end}}{{range $k, $v := $m2m.OtherFK.Column}}AND({{$relTable.SQLName}}.{{$v.Self.SQLName}} = {{$oTable.SQLName}}.{{$v.Other.SQLName}}){{end}}",
		{{range $k, $v := $m2m.MyFK.Column}}{{if $k}}, {{end}}t.{{$v.Other.GoName}}{{end}},
	)
  if err != nil {
  	return nil, nil, err
  }
	defer r.Close()

	ot, rt := []{{$oTable.GoName}}{}, []{{$relTable.GoName}}{}
	for r.Next() {
		var oe {{$oTable.GoName}}
		var re {{$relTable.GoName}}
		if err = r.Scan({{range $k, $v := $oTable.Column}}{{if $k}}, {{end}}&oe.{{$v.GoName}}{{end}}{{range $k, $v := $relTable.Column}}, &re.{{$v.GoName}}{{end}}); err != nil {
  		return nil, nil, err
  	}
		ot, rt = append(ot, oe), append(rt, re)
	}
	if err = r.Err(); err != nil {
		return nil, nil, err
	}
	return ot, rt, nil
}
{{if $t.OmitMethod $method}}*/{{end}}
{{end}}

{{$method := "Insert"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	{{$aicol := .AutoIncrementColumn}}
	{{if $aicol}}
		i, err := t.schema.Mode().Insert(db, t.schema.TableName(), t.schema.Columns(), t.schema.Values(t), t.schema.AutoIncrementColumnIndex())
		if err != nil {
			return err
		}
		if i != 0 {
			t.{{$aicol.GoName}} = {{if eq $aicol.GoStructFieldType "int64"}}i{{else}}{{$aicol.GoStructFieldType}}(i){{end}}
		}
		return nil
	{{else}}
		_, err := t.schema.Mode().Insert(db, t.schema.TableName(), t.schema.Columns(), t.schema.Values(t), t.schema.AutoIncrementColumnIndex())
		return err
	{{end}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Update"}}
{{if .OmitMethod $method}}/*{{end}}
{{if .NonPrimaryKeys}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	{{$ph := .Mode.Placeholder}}
	_, err := db.Exec(
		"UPDATE {{.SQLName}} SET {{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}{{$v.SQLName}} = {{$ph.Next}}{{end}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}t.{{$v.GoName}}{{end}},
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}t.{{$v.GoName}}{{end}},
	)
	return err

}
{{else}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	// {{.GoName}} has primary key only
	return nil
}
{{end}}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Delete"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	{{$ph := .Mode.Placeholder}}
	_, err := db.Exec(
		"DELETE FROM {{.SQLName}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}t.{{$v.GoName}}{{end}},
	)
	return err

}
{{if .OmitMethod $method}}*/{{end}}

// zz{{.GoName}} represents {{.GoName}} table schema.
type zz{{.GoName}} struct {}

{{$method := "TableName"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.GoName}}) {{$method}}() string {
	return {{printf "%q" .SQLName}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Columns"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.GoName}}) {{$method}}() []string {
	return []string{ {{range $k, $v := .Column}}{{if $k}},{{end}}{{printf "%q" $v.SQLName}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "AutoIncrementColumnIndex"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.GoName}}) {{$method}}() int {
	return {{if .AutoIncrementColumn}}{{range $k, $v := .Column}}{{if $v.AutoIncrement}}{{$k}}{{end}}{{end}}{{else}}-1{{end}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Values"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.GoName}}) {{$method}}(t *{{.GoName}}) []interface{} {
	return []interface{}{ {{range $k, $v := .Column}}{{if $k}},{{end}}t.{{$v.GoName}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Pointers"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.GoName}}) {{$method}}(t *{{.GoName}}) []interface{} {
	return []interface{}{ {{range $k, $v := .Column}}{{if $k}},{{end}}&t.{{$v.GoName}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Mode"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.GoName}}) {{$method}}() sqruct.Mode {
	return sqruct.{{.Mode}}
}
{{if .OmitMethod $method}}*/{{end}}

`
