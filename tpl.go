package sqruct

const createTableTemplate = `CREATE TABLE {{.SQLName}}(
	{{range $k, $v := .Column}}{{if $k}},
	{{end}}{{$v.SQLName}} {{$v.SQLColumn}}{{end}}{{range $k, $v := .ColumnAfter}},
	{{$v}}{{end}}
);`

const dropTableTemplate = `DROP TABLE {{.SQLName}};`

const sourceTemplate = `

// DO NOT EDIT. This file was auto-generated by Sqruct.

package {{.PackageName}}

// {{.GoName}} represents the following table.
{{.MustCreateTableSQL.AddPrefix "// \t"}}
type {{.GoName}} struct {
{{range $k, $v := .Column}}  {{$v.GoName}} {{$v.GoStructFieldWithTag}}
{{end}}}

{{$method := print "Get" .GoName}}
{{if .OmitMethod $method}}/*{{end}}
func {{$method}}(db sqruct.DB{{range $k, $v := .PrimaryKey.Column}}, {{$v.SQLName}} {{$v.GoStructFieldType}}{{end}}) (*{{.GoName}}, error) {
	{{$g := .Mode.PlaceholderGenerator}}
	var t {{.GoName}}
  err := db.QueryRow(
		"SELECT {{range $k, $v := .Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}} FROM {{.SQLName}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = {{$g.Placeholder}}){{end}}",
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}},
	).Scan({{range $k, $v := .Column}}{{if $k}}, {{end}}&t.{{$v.GoName}}{{end}})
	if err != nil {
  	return nil, err
  }
  return &t, nil

}
{{if .OmitMethod $method}}*/{{end}}

{{$t := .}}
{{range $_, $fk := .ForeignKey}}
{{if and (eq (len $fk.Column) 1) (index $fk.Column 0).Other.PrimaryKey}}
{{$method := print "Get" $fk.Table.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(db sqruct.DB) (*{{$fk.Table.GoName}}, error) {
	{{$g := $t.Mode.PlaceholderGenerator}}
	var ot {{$fk.Table.GoName}}
  err := db.QueryRow(
		"SELECT {{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}} FROM {{$fk.Table.SQLName}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.SQLName}} = {{$g.Placeholder}}){{end}}",
		{{range $k, $v := $fk.Column}}{{if $k}}, {{end}}t.{{$v.Self.GoName}}{{end}},
	).Scan({{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}&ot.{{$v.GoName}}{{end}})
	if err != nil {
  	return nil, err
  }
  return &ot, nil

}
{{if $t.OmitMethod $method}}*/{{end}}
{{else}}
{{$method := print "Select" $fk.Table.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(db sqruct.DB) ([]{{$fk.Table.GoName}}, error) {
	{{$g := $t.Mode.PlaceholderGenerator}}
	r, err := db.Query(
		"SELECT {{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}{{$v.SQLName}}{{end}} FROM {{$fk.Table.SQLName}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.SQLName}} = {{$g.Placeholder}}){{end}}",
		{{range $k, $v := $fk.Column}}{{if $k}}, {{end}}t.{{$v.Self.GoName}}{{end}},
	)
  if err != nil {
  	return nil, err
  }
	defer r.Close()

  var ot []{{$fk.Table.GoName}}
	for r.Next() {
		var e {{$fk.Table.GoName}}
		if err = r.Scan({{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}&e.{{$v.GoName}}{{end}}); err != nil {
  		return nil, err
  	}
		ot = append(ot, e)
	}
	if err = r.Err(); err != nil {
		return nil, err
	}
	if ot == nil {
		return nil, sql.ErrNoRows
	}
	return ot, nil

}
{{if $t.OmitMethod $method}}*/{{end}}
{{end}}
{{end}}

{{$method := "TableName"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}() string {
	return {{printf "%q" .SQLName}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Columns"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}() []string {
	return []string{ {{range $k, $v := .Column}}{{if $k}},{{end}}{{printf "%q" $v.SQLName}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Values"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}() []interface{} {
	return []interface{}{ {{range $k, $v := .Column}}{{if $k}},{{end}}t.{{$v.GoName}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "AutoIncrementColumnIndex"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}() int {
	return {{if .AutoIncrementColumn}}{{range $k, $v := .Column}}{{if $v.AutoIncrement}}{{$k}}{{end}}{{end}}{{else}}-1{{end}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "SqructMode"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}() sqruct.Mode {
	return sqruct.{{.Mode}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Insert"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	{{$aicol := .AutoIncrementColumn}}
	{{if $aicol}}
		i, err := t.SqructMode().Insert(db, t.TableName(), t.Columns(), t.Values(), t.AutoIncrementColumnIndex())
		if err != nil {
			return err
		}
		if i != 0 {
			t.{{$aicol.GoName}} = {{if eq $aicol.GoStructFieldType "int64"}}i{{else}}{{$aicol.GoStructFieldType}}(i){{end}}
		}
		return nil
	{{else}}
		_, err := t.SqructMode().Insert(db, t.TableName(), t.Columns(), t.Values(), t.AutoIncrementColumnIndex())
		return err
	{{end}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Update"}}
{{if .OmitMethod $method}}/*{{end}}
{{if .NonPrimaryKeys}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	{{$g := .Mode.PlaceholderGenerator}}
	_, err := db.Exec(
		"UPDATE {{.SQLName}} SET {{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}{{$v.SQLName}} = {{$g.Placeholder}}{{end}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = {{$g.Placeholder}}){{end}}",
		{{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}t.{{$v.GoName}}{{end}},
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}t.{{$v.GoName}}{{end}},
	)
	return err

}
{{else}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	// {{.GoName}} has primary key only
	return nil
}
{{end}}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Delete"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}(db sqruct.DB) error {
	{{$g := .Mode.PlaceholderGenerator}}
	_, err := db.Exec(
		"DELETE FROM {{.SQLName}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = {{$g.Placeholder}}){{end}}",
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}t.{{$v.GoName}}{{end}},
	)
	return err

}
{{if .OmitMethod $method}}*/{{end}}
`
