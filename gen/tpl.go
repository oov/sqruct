package gen

const createTableTemplate = `CREATE TABLE {{.Name.SQLQuoted}}(
	{{range $k, $v := .Column}}{{if $k}},
	{{end}}{{$v.Name.SQLQuoted}} {{$v.SQLColumn}}{{end}}{{range $k, $v := .ColumnAfter}},
	{{$v}}{{end}}
);`

const dropTableTemplate = `DROP TABLE {{.Name.SQLForGo}};`

const sourceTemplate = `

// DO NOT EDIT. This file was auto-generated by Sqruct.

package {{.PackageName}}

// {{.Name.Go}} represents the following table.
{{.MustCreateTableSQL.AddPrefix "// \t"}}
type {{.Name.Go}} struct {
	schema zz{{.Name.Go}}
{{range $k, $v := .Column}}  {{$v.Name.Go}} {{$v.GoStructFieldWithTag}}
{{end}}}

{{$method := print "Get" .Name.Go}}
{{if .OmitMethod $method}}/*{{end}}
func {{$method}}(db sqruct.DB{{range $k, $v := .PrimaryKey.Column}}, {{$v.Name.GoLower}} {{$v.GoStructFieldType}}{{end}}) (*{{.Name.Go}}, error) {
	{{$ph := .Mode.Placeholder}}
	var t {{.Name.Go}}
  err := db.QueryRow(
		"SELECT {{range $k, $v := .Column}}{{if $k}}, {{end}}{{$v.Name.SQLForGo}}{{end}} FROM {{.Name.SQLForGo}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.Name.SQLForGo}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}{{$v.Name.GoLower}}{{end}},
	).Scan({{range $k, $v := .Column}}{{if $k}}, {{end}}&t.{{$v.Name.Go}}{{end}})
	if err != nil {
  	return nil, err
  }
  return &t, nil

}
{{if .OmitMethod $method}}*/{{end}}

{{$t := .}}
{{range $_, $fk := .ForeignKey}}
{{if and (eq (len $fk.Column) 1) (index $fk.Column 0).Other.PrimaryKey}}
{{$method := print "Get" $fk.Table.Name.Go}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.Name.Go}}) {{$method}}(db sqruct.DB) (*{{$fk.Table.Name.Go}}, error) {
	{{$ph := $t.Mode.Placeholder}}
	var ot {{$fk.Table.Name.Go}}
  err := db.QueryRow(
		"SELECT {{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}{{$v.Name.SQLForGo}}{{end}} FROM {{$fk.Table.Name.SQLForGo}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.Name.SQLForGo}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := $fk.Column}}{{if $k}}, {{end}}t.{{$v.Self.Name.Go}}{{end}},
	).Scan({{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}&ot.{{$v.Name.Go}}{{end}})
	if err != nil {
  	return nil, err
  }
  return &ot, nil

}
{{if $t.OmitMethod $method}}*/{{end}}
{{else}}
{{$method := print "Select" $fk.Table.Name.Go}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.Name.Go}}) {{$method}}(db sqruct.DB) ([]{{$fk.Table.Name.Go}}, error) {
	{{$ph := $t.Mode.Placeholder}}
	r, err := db.Query(
		"SELECT {{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}{{$v.Name.SQLForGo}}{{end}} FROM {{$fk.Table.Name.SQLForGo}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.Name.SQLForGo}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := $fk.Column}}{{if $k}}, {{end}}t.{{$v.Self.Name.Go}}{{end}},
	)
  if err != nil {
  	return nil, err
  }
	defer r.Close()

	ot := []{{$fk.Table.Name.Go}}{}
	for r.Next() {
		var e {{$fk.Table.Name.Go}}
		if err = r.Scan({{range $k, $v := $fk.Table.Column}}{{if $k}}, {{end}}&e.{{$v.Name.Go}}{{end}}); err != nil {
  		return nil, err
  	}
		ot = append(ot, e)
	}
	if err = r.Err(); err != nil {
		return nil, err
	}
	return ot, nil

}
{{if $t.OmitMethod $method}}*/{{end}}
{{end}}
{{end}}

{{$t := .}}
{{range $_, $m2m := .ManyToMany}}
{{$relTable := $m2m.RelTable}}
{{$oTable := $m2m.OtherFK.Table}}
{{$method := print "Select" $oTable.Name.Go}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.Name.Go}}) {{$method}}(db sqruct.DB) ([]{{$oTable.Name.Go}}, []{{$relTable.Name.Go}}, error) {
	{{$ph := $t.Mode.Placeholder}}
	r, err := db.Query(
		"SELECT {{range $k, $v := $oTable.Column}}{{if $k}}, {{end}}{{$oTable.Name.SQLForGo}}.{{$v.Name.SQLForGo}}{{end}}{{range $k, $v := $relTable.Column}}, {{$relTable.Name.SQLForGo}}.{{$v.Name.SQLForGo}}{{end}} FROM {{$relTable.Name.SQLForGo}}, {{$oTable.Name.SQLForGo}} WHERE {{range $k, $v := $m2m.MyFK.Column}}{{if $k}}AND{{end}}({{$relTable.Name.SQLForGo}}.{{$v.Self.Name.SQLForGo}} = {{$ph.Next}}){{end}}{{range $k, $v := $m2m.OtherFK.Column}}AND({{$relTable.Name.SQLForGo}}.{{$v.Self.Name.SQLForGo}} = {{$oTable.Name.SQLForGo}}.{{$v.Other.Name.SQLForGo}}){{end}}",
		{{range $k, $v := $m2m.MyFK.Column}}{{if $k}}, {{end}}t.{{$v.Other.Name.Go}}{{end}},
	)
  if err != nil {
  	return nil, nil, err
  }
	defer r.Close()

	ot, rt := []{{$oTable.Name.Go}}{}, []{{$relTable.Name.Go}}{}
	for r.Next() {
		var oe {{$oTable.Name.Go}}
		var re {{$relTable.Name.Go}}
		if err = r.Scan({{range $k, $v := $oTable.Column}}{{if $k}}, {{end}}&oe.{{$v.Name.Go}}{{end}}{{range $k, $v := $relTable.Column}}, &re.{{$v.Name.Go}}{{end}}); err != nil {
  		return nil, nil, err
  	}
		ot, rt = append(ot, oe), append(rt, re)
	}
	if err = r.Err(); err != nil {
		return nil, nil, err
	}
	return ot, rt, nil
}
{{if $t.OmitMethod $method}}*/{{end}}
{{end}}

{{$method := "Insert"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.Name.Go}}) {{$method}}(db sqruct.DB) error {
	{{$aicol := .AutoIncrementColumn}}
	{{if $aicol}}
		i, err := t.schema.Mode().Insert(db, t.schema.TableName(), t.schema.Columns(), t.schema.Values(t), t.schema.AutoIncrementColumnIndex())
		if err != nil {
			return err
		}
		if i != 0 {
			t.{{$aicol.Name.Go}} = {{if eq $aicol.GoStructFieldType "int64"}}i{{else}}{{$aicol.GoStructFieldType}}(i){{end}}
		}
		return nil
	{{else}}
		_, err := t.schema.Mode().Insert(db, t.schema.TableName(), t.schema.Columns(), t.schema.Values(t), t.schema.AutoIncrementColumnIndex())
		return err
	{{end}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Update"}}
{{if .OmitMethod $method}}/*{{end}}
{{if .NonPrimaryKeys}}
func (t *{{.Name.Go}}) {{$method}}(db sqruct.DB) error {
	{{$ph := .Mode.Placeholder}}
	_, err := db.Exec(
		"UPDATE {{.Name.SQLForGo}} SET {{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}{{$v.Name.SQLForGo}} = {{$ph.Next}}{{end}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.Name.SQLForGo}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}t.{{$v.Name.Go}}{{end}},
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}t.{{$v.Name.Go}}{{end}},
	)
	return err

}
{{else}}
func (t *{{.Name.Go}}) {{$method}}(db sqruct.DB) error {
	// {{.Name.Go}} has primary key only
	return nil
}
{{end}}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Delete"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.Name.Go}}) {{$method}}(db sqruct.DB) error {
	{{$ph := .Mode.Placeholder}}
	_, err := db.Exec(
		"DELETE FROM {{.Name.SQLForGo}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.Name.SQLForGo}} = {{$ph.Next}}){{end}}",
		{{range $k, $v := .PrimaryKey.Column}}{{if $k}}, {{end}}t.{{$v.Name.Go}}{{end}},
	)
	return err

}
{{if .OmitMethod $method}}*/{{end}}

// zz{{.Name.Go}} represents {{.Name.Go}} table schema.
type zz{{.Name.Go}} struct {}

{{$method := "TableName"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.Name.Go}}) {{$method}}() string {
	return {{printf "%q" .Name.SQL}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Columns"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.Name.Go}}) {{$method}}() []string {
	return []string{ {{range $k, $v := .Column}}{{if $k}},{{end}}{{printf "%q" $v.Name.SQL}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "AutoIncrementColumnIndex"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.Name.Go}}) {{$method}}() int {
	return {{if .AutoIncrementColumn}}{{range $k, $v := .Column}}{{if $v.AutoIncrement}}{{$k}}{{end}}{{end}}{{else}}-1{{end}}
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Values"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.Name.Go}}) {{$method}}(t *{{.Name.Go}}) []interface{} {
	return []interface{}{ {{range $k, $v := .Column}}{{if $k}},{{end}}t.{{$v.Name.Go}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Pointers"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.Name.Go}}) {{$method}}(t *{{.Name.Go}}) []interface{} {
	return []interface{}{ {{range $k, $v := .Column}}{{if $k}},{{end}}&t.{{$v.Name.Go}}{{end}} }
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Mode"}}
{{if .OmitMethod $method}}/*{{end}}
func (zz{{.Name.Go}}) {{$method}}() sqruct.Mode {
	return sqruct.{{.Mode}}
}
{{if .OmitMethod $method}}*/{{end}}

`
