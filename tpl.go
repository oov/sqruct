package sqruct

const createTableTemplate = `CREATE TABLE {{.SQLName}}(
	{{range $k, $v := .Column}}{{if $k}},
	{{end}}{{$v.SQLName}} {{$v.SQLColumn}}{{end}}{{range $k, $v := .ColumnAfter}},
	{{$v}}{{end}}
);`

const dropTableTemplate = `DROP TABLE {{.SQLName}};`

const sourceTemplate = `

// DO NOT EDIT. This file was auto-generated by Sqruct.

package {{.PackageName}}

// {{.GoName}} represents the following table.
{{.MustCreateTableSQL.AddPrefix "// \t"}}
type {{.GoName}} struct {
{{range $k, $v := .Column}}  {{$v.GoName}} {{$v.GoStructFieldWithTag}}
{{end}}}

{{$method := print "Get" .GoName}}
{{if .OmitMethod $method}}/*{{end}}
func {{$method}}(e sqlx.Ext{{range $k, $v := .PrimaryKey.Column}}, {{$v.SQLName}} {{$v.GoStructFieldType}}{{end}}) (*{{.GoName}}, error) {
  var t {{.GoName}}
  err := sqlx.Get(e, &t, e.Rebind("SELECT * FROM {{.SQLName}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = ?){{end}}"){{range $k, $v := .PrimaryKey.Column}}, {{$v.SQLName}}{{end}})
  if err != nil {
  	return nil, err
  }
  return &t, nil
}
{{if .OmitMethod $method}}*/{{end}}

{{$t := .}}
{{range $_, $fk := .ForeignKey}}
{{if and (eq (len $fk.Column) 1) (index $fk.Column 0).Other.PrimaryKey}}
{{$method := print "Get" $fk.Table.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(e sqlx.Ext) (*{{$fk.Table.GoName}}, error) {
  var ot {{$fk.Table.GoName}}
  err := sqlx.Get(e, &ot, e.Rebind("SELECT * FROM {{$fk.Table.SQLName}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.SQLName}} = ?){{end}}"){{range $k, $v := $fk.Column}}, t.{{$v.Self.GoName}}{{end}})
  if err != nil {
  	return nil, err
  }
  return &ot, nil
}
{{if $t.OmitMethod $method}}*/{{end}}
{{else}}
{{$method := print "Select" $fk.Table.GoName}}
{{if $t.OmitMethod $method}}/*{{end}}
func (t *{{$t.GoName}}) {{$method}}(e sqlx.Ext) ([]{{$fk.Table.GoName}}, error) {
  var ot []{{$fk.Table.GoName}}
  err := sqlx.Select(e, &ot, e.Rebind("SELECT * FROM {{$fk.Table.SQLName}} WHERE {{range $k, $v := $fk.Column}}{{if $k}}AND{{end}}({{$v.Other.SQLName}} = ?){{end}}"){{range $k, $v := $fk.Column}}, t.{{$v.Self.GoName}}{{end}})
  if err != nil {
  	return nil, err
  }
  return ot, nil
}
{{if $t.OmitMethod $method}}*/{{end}}
{{end}}
{{end}}

{{$method := "Insert"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}(e sqlx.Ext) error {
	{{range $k, $v := .Column}}{{if $v.AutoIncrement}}z := sqruct.IsZero(t.{{$v.GoName}}){{end}}{{end}}
	r, err := sqlx.NamedExec(e, sqruct.BuildInsertQuery(
		{{printf "%q" .SQLName}},
		[]string{ {{range $k, $v := .Column}}{{if $k}},{{end}}{{printf "%q" $v.SQLName}}{{end}} },
		[]bool{ {{range $k, $v := .Column}}{{if $k}},{{end}}{{if $v.AutoIncrement}}!z{{else}}true{{end}}{{end}} },
	), t)
	if err != nil {
		return err
	}
	{{range $k, $v := .Column}}{{if $v.AutoIncrement}}if z {
		t.{{$v.GoName}}, err = r.LastInsertId()
		return err
	}{{end}}{{end}}
	return nil
}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Update"}}
{{if .OmitMethod $method}}/*{{end}}
{{if .NonPrimaryKeys}}
func (t *{{.GoName}}) {{$method}}(e sqlx.Ext) error {
	_, err := sqlx.NamedExec(e, "UPDATE {{.SQLName}} SET {{range $k, $v := .NonPrimaryKeys}}{{if $k}}, {{end}}{{$v.SQLName}} = :{{$v.SQLName}}{{end}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = :{{$v.SQLName}}){{end}}", t)
	return err
}
{{else}}
func (t *{{.GoName}}) {{$method}}(e sqlx.Ext) error {
	// {{.GoName}} has primary key only
	return nil
}
{{end}}
{{if .OmitMethod $method}}*/{{end}}

{{$method := "Delete"}}
{{if .OmitMethod $method}}/*{{end}}
func (t *{{.GoName}}) {{$method}}(e sqlx.Ext) error {
	_, err := sqlx.NamedExec(e, "DELETE FROM {{.SQLName}} WHERE {{range $k, $v := .PrimaryKey.Column}}{{if $k}}AND{{end}}({{$v.SQLName}} = :{{$v.SQLName}}){{end}}", t)
	return err
}
{{if .OmitMethod $method}}*/{{end}}
`
